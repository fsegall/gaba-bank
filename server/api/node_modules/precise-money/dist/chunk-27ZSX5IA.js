// src/core.ts
var POW10 = Array.from({ length: 39 }, (_, i) => 10n ** BigInt(i));
var BPS_BASE = 10000n;
function pow10(n) {
  if (!Number.isInteger(n) || n < 0) throw new Error("pow10 expects non-negative integer");
  return n < POW10.length ? POW10[n] : 10n ** BigInt(n);
}
function scaleUnits(u, fromDec, toDec, opts) {
  if (!Number.isInteger(fromDec) || !Number.isInteger(toDec) || fromDec < 0 || toDec < 0)
    throw new Error("scaleUnits: decimals must be non-negative integers");
  if (fromDec === toDec) return u;
  if (fromDec < toDec) {
    return u * pow10(toDec - fromDec);
  }
  return divRound(u, pow10(fromDec - toDec), opts?.mode ?? "floor");
}
function normalizeAmountInput(x) {
  let s = typeof x === "number" ? String(x) : x;
  s = s.trim();
  if (s === "") throw new Error("empty amount");
  let sign = 1n;
  if (s[0] === "+") s = s.slice(1);
  else if (s[0] === "-") {
    sign = -1n;
    s = s.slice(1);
  }
  s = s.replace(/\s+/g, "").replace(/_/g, "");
  const lastDot = s.lastIndexOf(".");
  const lastComma = s.lastIndexOf(",");
  let decSep = "";
  if (lastDot >= 0 || lastComma >= 0) decSep = lastDot > lastComma ? "." : ",";
  if (decSep) {
    const parts = s.split(decSep);
    const intPart = (parts[0] || "0").replace(/[.,\s]/g, "");
    const fracPart = parts.slice(1).join("").replace(/[.,\s]/g, "");
    if (!/^\d+$/.test(intPart) || fracPart && !/^\d+$/.test(fracPart)) throw new Error(`invalid amount: ${x}`);
    const intNorm = intPart.replace(/^0+(?=\d)/, "") || "0";
    return { sign, int: intNorm, frac: fracPart };
  } else {
    const digits = s.replace(/[.,\s]/g, "");
    if (!/^\d+$/.test(digits)) throw new Error(`invalid amount: ${x}`);
    const intNorm = digits.replace(/^0+(?=\d)/, "") || "0";
    return { sign, int: intNorm, frac: "" };
  }
}
function toMinor(human, decimals, opts) {
  if (!Number.isInteger(decimals) || decimals < 0) throw new Error("toMinor: decimals must be non-negative integer");
  const { sign, int, frac } = normalizeAmountInput(human);
  const mode = opts?.mode ?? "round";
  const padded = (frac + "0".repeat(decimals + 1)).slice(0, decimals + 1);
  const core = padded.slice(0, decimals);
  const roundDigit = Number(padded.slice(decimals, decimals + 1) || "0");
  let base = BigInt(int) * pow10(decimals) + BigInt(core || "0");
  if (roundDigit > 0) {
    base = roundAdjust(base, 1, mode);
  }
  return sign < 0n ? -base : base;
}
function fromMinor(minor, decimals) {
  if (!Number.isInteger(decimals) || decimals < 0) throw new Error("fromMinor: decimals must be non-negative integer");
  const neg = minor < 0n;
  const abs = neg ? -minor : minor;
  const scale = pow10(decimals);
  const i = abs / scale;
  const f = (abs % scale).toString().padStart(decimals, "0");
  return (neg ? "-" : "") + (decimals === 0 ? i.toString() : `${i}.${f}`);
}
function applySlippage(amountOutMinor, slippageBps) {
  if (!Number.isFinite(slippageBps) || slippageBps < 0) throw new Error("slippageBps must be >= 0");
  const num = BPS_BASE - BigInt(Math.trunc(slippageBps));
  return amountOutMinor * num / BPS_BASE;
}
function minOutForExactIn(amountOutMinor, slippageBps) {
  return applySlippage(amountOutMinor, slippageBps);
}
function splitAmount(totalMinor, lotSizeMinor) {
  if (lotSizeMinor <= 0n) throw new Error("lotSizeMinor must be > 0");
  const chunks = [];
  let left = totalMinor;
  while (left >= lotSizeMinor) {
    chunks.push(lotSizeMinor);
    left -= lotSizeMinor;
  }
  if (left > 0n) chunks.push(left);
  return chunks;
}
function mulDiv(a, b, c, mode = "round") {
  const bb = typeof b === "number" ? BigInt(b) : b;
  const cc = typeof c === "number" ? BigInt(c) : c;
  if (cc === 0n) throw new Error("division by zero");
  return divRound(a * bb, cc, mode);
}
function applyBps(units, bps, mode = "round") {
  return mulDiv(units, Math.trunc(bps), BPS_BASE, mode);
}
function clampBps(bps) {
  return Math.max(0, Math.min(1e4, Math.trunc(bps)));
}
function slippageDown(amountMinor, bps) {
  const b = BigInt(clampBps(bps));
  return amountMinor * (BPS_BASE - b) / BPS_BASE;
}
function slippageUp(amountMinor, bps) {
  const b = BigInt(clampBps(bps));
  const num = amountMinor * (BPS_BASE + b);
  const q = num / BPS_BASE;
  const r = num % BPS_BASE;
  return r === 0n ? q : q + 1n;
}
function priceRatioDecimals(quoteDecimals, priceStr) {
  if (!Number.isInteger(quoteDecimals) || quoteDecimals < 0) throw new Error("quoteDecimals must be non-negative integer");
  const n = normalizeAmountInput(priceStr);
  if (n.sign < 0n) throw new Error("negative price not allowed");
  const num = BigInt(n.int + (n.frac + "0".repeat(quoteDecimals)).slice(0, quoteDecimals));
  const den = pow10(quoteDecimals);
  return { num, den };
}
function convertUnitsByDecimals(amountUnits, fromDec, toDec, price, mode = "round") {
  if (!Number.isInteger(fromDec) || !Number.isInteger(toDec) || fromDec < 0 || toDec < 0)
    throw new Error("convertUnitsByDecimals: decimals must be non-negative integers");
  const diff = toDec - fromDec;
  const scaleNum = diff >= 0 ? pow10(diff) : 1n;
  const scaleDen = diff < 0 ? pow10(-diff) : 1n;
  return mulDiv(mulDiv(amountUnits, price.num, price.den, mode), scaleNum, scaleDen, mode);
}
function divToDecimalString(numer, denom, scale = 8) {
  if (denom === 0n) throw new Error("division by zero");
  if (!Number.isInteger(scale) || scale < 0) throw new Error("scale must be a non-negative integer");
  const neg = numer < 0n !== denom < 0n;
  const a = absBig(numer);
  const b = absBig(denom);
  const scaled = a * pow10(scale);
  const i = scaled / b;
  const s = i.toString().padStart(scale + 1, "0");
  const head = s.slice(0, -scale) || "0";
  const tail = s.slice(-scale);
  return (neg ? "-" : "") + head + (scale > 0 ? "." + tail : "");
}
function avgFiatPricePerUnit(params) {
  const { filledQtyMinor, spentFiatMinor, outDecimals, fiatDecimals, scale = 8 } = params;
  if (filledQtyMinor <= 0n) throw new Error("avgFiatPricePerUnit: filledQtyMinor must be > 0");
  if (!Number.isInteger(outDecimals) || outDecimals < 0) throw new Error("avgFiatPricePerUnit: outDecimals must be a non-negative integer");
  if (!Number.isInteger(fiatDecimals) || fiatDecimals < 0) throw new Error("avgFiatPricePerUnit: fiatDecimals must be a non-negative integer");
  if (!Number.isInteger(scale) || scale < 0) throw new Error("avgFiatPricePerUnit: scale must be a non-negative integer");
  const numer = spentFiatMinor * pow10(outDecimals);
  const denom = filledQtyMinor * pow10(fiatDecimals);
  return divToDecimalString(numer, denom, scale);
}
function divRound(n, d, mode) {
  if (d === 0n) throw new Error("division by zero");
  const q = n / d;
  const r = n % d;
  if (r === 0n) return q;
  const sign = n > 0n === d > 0n ? 1 : -1;
  switch (mode) {
    case "floor":
      return sign < 0 ? q - 1n : q;
    case "ceil":
      return sign > 0 ? q + 1n : q;
    case "round":
      return absBig(r * 2n) >= absBig(d) ? q + BigInt(sign) : q;
    case "bankers": {
      const twice = absBig(r * 2n);
      if (twice > absBig(d)) return q + BigInt(sign);
      if (twice < absBig(d)) return q;
      return q % 2n === 0n ? q : q + BigInt(sign);
    }
  }
}
function roundAdjust(base, sign, mode) {
  switch (mode) {
    case "ceil":
      return sign > 0 ? base + 1n : base;
    case "round":
      return base + BigInt(sign);
    case "bankers":
      return base % 2n === 0n ? base : base + BigInt(sign);
    case "floor":
    default:
      return base;
  }
}
function absBig(x) {
  return x < 0n ? -x : x;
}

// src/registry.ts
var bySymbol = /* @__PURE__ */ new Map();
var byId = /* @__PURE__ */ new Map();
function idKey(id) {
  return [id.chain, id.chainId ?? "", id.symbol.toUpperCase(), id.address ?? "", id.issuer ?? ""].join(":");
}
var DEC = {
  get(symbol) {
    return bySymbol.get(symbol.toUpperCase());
  },
  set(symbol, dec) {
    bySymbol.set(symbol.toUpperCase(), dec);
  },
  getById(id) {
    return byId.get(idKey(id));
  },
  setById(id, dec) {
    byId.set(idKey(id), dec);
  }
};
DEC.set("BRL", 2);
DEC.set("USD", 2);
DEC.set("USDC", 6);
DEC.set("USDT", 6);

export {
  scaleUnits,
  normalizeAmountInput,
  toMinor,
  fromMinor,
  applySlippage,
  minOutForExactIn,
  splitAmount,
  mulDiv,
  applyBps,
  clampBps,
  slippageDown,
  slippageUp,
  priceRatioDecimals,
  convertUnitsByDecimals,
  divToDecimalString,
  avgFiatPricePerUnit,
  DEC
};
