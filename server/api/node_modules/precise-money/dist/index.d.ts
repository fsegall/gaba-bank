export { stellarClassicFromMinor, stellarClassicToMinor, stellarFromMinor, stellarResolveDecimals, stellarToMinor } from './adapters/stellar.js';
export { evmEnsureDecimals, evmFetchDecimalsViaViem, evmFromMinor, evmResolveDecimals, evmToMinor } from './adapters/evm.js';
export { solanaEnsureDecimals, solanaFetchMintDecimalsViaParsed, solanaFromMinor, solanaResolveDecimals, solanaToMinor } from './adapters/solana.js';
export { cosmosEnsureDecimals, cosmosFetchDecimalsViaBank, cosmosFromMinor, cosmosResolveDecimals, cosmosToMinor } from './adapters/cosmos.js';

/**
 * @defy-labs/precise-money — core.ts
 * Pure BigInt math for cross-chain units. No chain SDKs, no ENV access.
 */
type Rounding = 'floor' | 'ceil' | 'round' | 'bankers';
/** Scale an integer amount between different decimal precisions. */
declare function scaleUnits(u: bigint, fromDec: number, toDec: number, opts?: {
    mode?: Rounding;
}): bigint;
/**
 * Normalize human input like:
 *  "1.234,56", "1_234.56", "  -12.3  "
 * into components: sign/int/frac  →  { sign: 1n|-1n, int: "1234", frac: "56" }
 * Strategy: detect the *last* '.' or ',' as decimal separator; all other separators are removed.
 */
declare function normalizeAmountInput(x: string | number): {
    sign: 1n | -1n;
    int: string;
    frac: string;
};
/**
 * Convert a human string/number (e.g. "12.345") to minor units bigint given decimals.
 * Default rounding is 'round' (half-up behavior).
 */
declare function toMinor(human: string | number, decimals: number, opts?: {
    mode?: Rounding;
}): bigint;
/** Convert minor units bigint back to a human string with exactly `decimals` fractional digits. */
declare function fromMinor(minor: bigint, decimals: number): string;
/** Apply slippage (in basis points) to an *output* amount → returns minOut (floored). */
declare function applySlippage(amountOutMinor: bigint, slippageBps: number): bigint;
/** Given a target output and slippage, compute the minimum acceptable output. */
declare function minOutForExactIn(amountOutMinor: bigint, slippageBps: number): bigint;
/** Split a total amount into lot-sized chunks (last chunk may be remainder). */
declare function splitAmount(totalMinor: bigint, lotSizeMinor: bigint): bigint[];
/** Multiply then divide with rounding: floor/ceil/round/bankers. */
declare function mulDiv(a: bigint, b: bigint | number, c: bigint | number, mode?: Rounding): bigint;
/** Apply percentage in basis points to a bigint amount. */
declare function applyBps(units: bigint, bps: number, mode?: Rounding): bigint;
/** Clamp bps to [0, 10000]. */
declare function clampBps(bps: number): number;
/** EXACT_IN → protect downward (minOut). */
declare function slippageDown(amountMinor: bigint, bps: number): bigint;
/** EXACT_OUT → protect upward (maxIn), using ceil division. */
declare function slippageUp(amountMinor: bigint, bps: number): bigint;
/**
 * Build a price ratio from a human price string scaled to `quoteDecimals`.
 * Interprets `priceStr` as QUOTE per 1 BASE.
 * Returns { num, den } such that price = num/den (both integers).
 */
declare function priceRatioDecimals(quoteDecimals: number, priceStr: string): {
    num: bigint;
    den: bigint;
};
/**
 * Convert units using a price ratio and explicit decimals.
 * amount_from * (num/den) * 10^(toDec - fromDec)
 */
declare function convertUnitsByDecimals(amountUnits: bigint, fromDec: number, toDec: number, price: {
    num: bigint;
    den: bigint;
}, mode?: Rounding): bigint;
/**
 * Divide two bigints and return a decimal string with `scale` fractional digits.
 * Example: divToDecimalString(123n, 10n, 4) → "12.3000"
 */
declare function divToDecimalString(numer: bigint, denom: bigint, scale?: number): string;
/**
 * Average FIAT price per OUT unit (string), using only BigInt math.
 * price = (spentFiatMinor / 10^fiatDecimals) / (filledQtyMinor / 10^outDecimals)
 * Returns a decimal string with `scale` fractional digits (default 8).
 */
declare function avgFiatPricePerUnit(params: {
    filledQtyMinor: bigint;
    spentFiatMinor: bigint;
    outDecimals: number;
    fiatDecimals: number;
    scale?: number;
}): string;

/**
* Decimals registry: by symbol and by full AssetId.
* Keep it simple; allow overrides at runtime.
*/
type Chain = 'stellar' | 'evm' | 'solana' | 'cosmos';
type AssetId = {
    chain: Chain;
    symbol: string;
    address?: string;
    issuer?: string;
    chainId?: number;
};
declare const DEC: {
    get(symbol: string): number | undefined;
    set(symbol: string, dec: number): void;
    getById(id: AssetId): number | undefined;
    setById(id: AssetId, dec: number): void;
};

export { type AssetId, type Chain, DEC, type Rounding, applyBps, applySlippage, avgFiatPricePerUnit, clampBps, convertUnitsByDecimals, divToDecimalString, fromMinor, minOutForExactIn, mulDiv, normalizeAmountInput, priceRatioDecimals, scaleUnits, slippageDown, slippageUp, splitAmount, toMinor };
